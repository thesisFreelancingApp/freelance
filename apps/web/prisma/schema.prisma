// Datasource et Générateur
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Enums
enum RequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  COMPLETED
  CANCELLED
}

// Define the Role enum in users.ts
enum Role {
  USER 
  ADMIN 
}


// ------------------------
// Modèles d'Authentification
// ------------------------

model AuthUser {
  id        String           @id
  email     String           @unique
  role      Role          @default(USER)
  name      String?
  username  String           @unique
  account   Account?
  profile   PersonalProfile? @relation("ProfileAuthUser")
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
}

model Account {
  id                Int      @id @default(autoincrement())
  lastProvider      String?
  providers         String[]
  providerAccountId String?
  userEmail         String   @unique
  user              AuthUser @relation(fields: [userEmail], references: [email], onDelete: Cascade)
  accessToken       String?
  refreshToken      String?
  expiresAt         Int?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// ------------------------
// Profils Utilisateurs et Rôles
// ------------------------

model PersonalProfile {
  id                    String                @id
  authUser              AuthUser              @relation("ProfileAuthUser", fields: [id], references: [id], onDelete: Cascade)
  firstName             String?
  lastName              String?
  profilePic            String?
  phoneNumber           String?
  address               String?
  bio                   String?
  birthDate             DateTime?
  userEmail             String                @unique
  professionalProfileid String?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt

  // Relations
  seller                Seller?
  buyer                 Buyer?
  messages              Message[]             @relation("MessageSender")
  notifications         Notification[]
  chatRooms             ChatRoomParticipant[] @relation("ProfileChatRooms")
  ratingsGiven          Rating[]              @relation("RatingRater")
  ratingsReceived       Rating[]              @relation("RatingRatee")
  createdServices       CustomService[]       @relation("CustomServiceCreator")
  participantIn         CustomServiceParticipant[]
  professionalProfile   ProfessionalProfile? @relation(fields: [professionalProfileid], references: [id])

}

model Seller {
  id                   String               @id
  profileId            String               @unique
  profile              PersonalProfile      @relation(fields: [profileId], references: [id], onDelete: Cascade)
  sellerRating         Float?
  totalEarnings        Float                @default(0.0)
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  // Relations
  createdServices      Service[]            @relation("CreatedServices")
  professionalProfile  ProfessionalProfile?
}

model Buyer {
  id                String          @id
  profileId         String          @unique
  profile           PersonalProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  totalSpent        Float           @default(0.0)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  // Relations
  purchasedServices Service[]       @relation("PurchasedServices")
}

// ------------------------
// Profil Professionnel
// ------------------------

model ProfessionalProfile {
  id               String          @id @default(uuid())
  sellerId         String          @unique
  language             String[]
  personalWebsite  String?         // Lien vers le site web personnel
  occupations      Json?           // Un tableau JSON pour stocker plusieurs occupations
  skills           Json?           // Un tableau JSON pour stocker plusieurs compétences
  educations       Json?           // Un tableau JSON pour stocker plusieurs entrées éducatives
  certifications   Json?           // Un tableau JSON pour stocker plusieurs certifications
  companyName      String?
  profession       String?
  experienceYears  Int?
  website          String?
  preferredCategoryId Int?         // Référence optionnelle à la catégorie préférée
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // Relations
  seller           Seller          @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  preferredCategory MainCategories? @relation(fields: [preferredCategoryId], references: [id])
  PersonalProfile  PersonalProfile[]
}


// ------------------------
// Modèles de Service
// ------------------------

model Service {
  id            String           @id @default(uuid())
  name          String
  description   String?
  images        String[]
  tags          String[]
  creatorId     String
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Relations
  creator       Seller           @relation("CreatedServices", fields: [creatorId], references: [id])
  buyers        Buyer[]          @relation("PurchasedServices")
  ratings       Rating[]         @relation("ServiceRatings")
  packages      ServicePackage[]
}

model ServicePackage {
  id            String    @id @default(uuid())
  serviceId     String
  name          String
  description   String
  price         Decimal   @db.Decimal(10, 2)
  deliveryTime  Int
  revisions     Int
  features      String[]

  // Relations
  service       Service   @relation(fields: [serviceId], references: [id])
}

// ------------------------
// Modèle de Notation
// ------------------------

model Rating {
  id              String           @id @default(uuid())
  raterId         String
  rateeId         String
  serviceId       String?
  customServiceId String?
  rating          Int
  review          String?
  createdAt       DateTime         @default(now())

  // Relations
  rater           PersonalProfile  @relation("RatingRater", fields: [raterId], references: [id])
  ratee           PersonalProfile  @relation("RatingRatee", fields: [rateeId], references: [id])
  service         Service?         @relation("ServiceRatings", fields: [serviceId], references: [id])
  customService   CustomService?   @relation(fields: [customServiceId], references: [id])
}

// ------------------------
// Demandes de Services Personnalisés
// ------------------------

model CustomService {
  id             String                   @id @default(uuid())
  creatorId      String
  assigneeId     String?
  title          String
  description    String
  minBudget      Decimal?                 @db.Decimal(10, 2)
  maxBudget      Decimal?                 @db.Decimal(10, 2)
  proposedPrice  Decimal?                 @db.Decimal(10, 2)
  message        String?
  status         RequestStatus            @default(PENDING)
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt

  // Relations
  creator        PersonalProfile          @relation("CustomServiceCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  ratings        Rating[]
  participants   CustomServiceParticipant[]
}

model CustomServiceParticipant {
  id               String            @id @default(uuid())
  customServiceId  String
  participantId    String
  joinedAt         DateTime          @default(now())

  // Relations
  customService    CustomService     @relation(fields: [customServiceId], references: [id], onDelete: Cascade)
  participant      PersonalProfile   @relation(fields: [participantId], references: [id], onDelete: Cascade)
}

// ------------------------
// Modèles de Chat
// ------------------------

model ChatRoom {
  id           String                @id @default(uuid())
  title        String?
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt

  // Relations
  participants ChatRoomParticipant[] @relation("ChatRoomParticipants")
  messages     Message[]
}

model ChatRoomParticipant {
  id             String           @id @default(uuid())
  chatRoomId     String
  participantId  String
  role           String
  createdAt      DateTime         @default(now())

  // Relations
  chatRoom       ChatRoom         @relation("ChatRoomParticipants", fields: [chatRoomId], references: [id])
  profile        PersonalProfile  @relation("ProfileChatRooms", fields: [participantId], references: [id])
}

model Message {
  id          String           @id @default(uuid())
  chatRoomId  String
  senderId    String
  content     String
  createdAt   DateTime         @default(now())

  // Relations
  chatRoom    ChatRoom         @relation(fields: [chatRoomId], references: [id])
  sender      PersonalProfile  @relation("MessageSender", fields: [senderId], references: [id])
}

// ------------------------
// Notifications
// ------------------------

model Notification {
  id          String           @id @default(uuid())
  recipientId String
  type        String?
  content     String?
  isRead      Boolean          @default(false)
  createdAt   DateTime         @default(now())

  // Relations
  recipient   PersonalProfile  @relation(fields: [recipientId], references: [id])
}

// ------------------------
// Catégories
// ------------------------

model MainCategories {
  id          Int              @id @default(autoincrement())
  name        String
  description String?
  level       Int
  parentId    Int?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  parent      MainCategories?  @relation("Hierarchy", fields: [parentId], references: [id])
  children    MainCategories[] @relation("Hierarchy")
  professionalProfiles ProfessionalProfile[] 
}
